[
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamSpWf",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferMemories_0:Memory_32/ramsSpWf:RamSpWf",
    "index":0.3282051282051282
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_32",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferMemories_0:Memory_32",
    "index":0.3333333333333333
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamSpWf_1",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferMemories_1:Memory_32/ramsSpWf:RamSpWf",
    "index":0.3384615384615385
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_33",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferMemories_1:Memory_32",
    "index":0.3435897435897436
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamSpWf_2",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferShadowMemories_0:Memory_32/ramsSpWf:RamSpWf",
    "index":0.3487179487179487
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_34",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferShadowMemories_0:Memory_32",
    "index":0.35384615384615387
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamSpWf_3",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferShadowMemories_1:Memory_32/ramsSpWf:RamSpWf",
    "index":0.358974358974359
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_35",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/backBufferShadowMemories_1:Memory_32",
    "index":0.3641025641025641
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_34",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_0:Memory_38/ramsSpWf:RamInitSpWf_34",
    "index":0.38974358974358975
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_38",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_0:Memory_38",
    "index":0.39487179487179486
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_35",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_1:Memory_39/ramsSpWf:RamInitSpWf_35",
    "index":0.4
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_39",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_1:Memory_39",
    "index":0.40512820512820513
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_36",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_2:Memory_40/ramsSpWf:RamInitSpWf_36",
    "index":0.41025641025641024
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_40",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_2:Memory_40",
    "index":0.4153846153846154
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_37",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_3:Memory_41/ramsSpWf:RamInitSpWf_37",
    "index":0.4205128205128205
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_41",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_3:Memory_41",
    "index":0.4256410256410256
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_38",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_4:Memory_42/ramsSpWf:RamInitSpWf_38",
    "index":0.4307692307692308
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_42",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_4:Memory_42",
    "index":0.4358974358974359
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_39",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_5:Memory_43/ramsSpWf:RamInitSpWf_39",
    "index":0.441025641025641
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_43",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_5:Memory_43",
    "index":0.4461538461538462
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_40",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_6:Memory_44/ramsSpWf:RamInitSpWf_40",
    "index":0.4512820512820513
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_44",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_6:Memory_44",
    "index":0.4564102564102564
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_41",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_7:Memory_45/ramsSpWf:RamInitSpWf_41",
    "index":0.46153846153846156
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_45",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_7:Memory_45",
    "index":0.4666666666666667
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_42",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_8:Memory_46/ramsSpWf:RamInitSpWf_42",
    "index":0.4717948717948718
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_46",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_8:Memory_46",
    "index":0.47692307692307695
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_43",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_9:Memory_47/ramsSpWf:RamInitSpWf_43",
    "index":0.48205128205128206
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_47",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_9:Memory_47",
    "index":0.48717948717948717
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_44",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_10:Memory_48/ramsSpWf:RamInitSpWf_44",
    "index":0.49230769230769234
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_48",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_10:Memory_48",
    "index":0.49743589743589745
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_45",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_11:Memory_49/ramsSpWf:RamInitSpWf_45",
    "index":0.5025641025641026
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_49",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_11:Memory_49",
    "index":0.5076923076923077
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_46",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_12:Memory_50/ramsSpWf:RamInitSpWf_46",
    "index":0.5128205128205128
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_50",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_12:Memory_50",
    "index":0.517948717948718
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_47",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_13:Memory_51/ramsSpWf:RamInitSpWf_47",
    "index":0.5230769230769231
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_51",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_13:Memory_51",
    "index":0.5282051282051282
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_48",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_14:Memory_52/ramsSpWf:RamInitSpWf_48",
    "index":0.5333333333333333
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_52",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_14:Memory_52",
    "index":0.5384615384615384
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_49",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_15:Memory_53/ramsSpWf:RamInitSpWf_49",
    "index":0.5435897435897435
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_53",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteMemories_15:Memory_53",
    "index":0.5487179487179488
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_50",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_0:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.5538461538461539
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_54",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_0:Memory_54",
    "index":0.558974358974359
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_51",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_1:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.5641025641025641
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_55",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_1:Memory_54",
    "index":0.5692307692307692
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_52",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_2:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.5743589743589743
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_56",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_2:Memory_54",
    "index":0.5794871794871795
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_53",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_3:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.5846153846153846
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_57",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_3:Memory_54",
    "index":0.5897435897435898
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_54",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_4:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.5948717948717949
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_58",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_4:Memory_54",
    "index":0.6
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_55",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_5:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6051282051282051
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_59",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_5:Memory_54",
    "index":0.6102564102564103
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_56",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_6:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6153846153846154
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_60",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_6:Memory_54",
    "index":0.6205128205128205
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_57",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_7:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6256410256410256
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_61",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_7:Memory_54",
    "index":0.6307692307692307
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_58",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_8:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6358974358974359
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_62",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_8:Memory_54",
    "index":0.6410256410256411
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_59",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_9:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6461538461538462
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_63",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_9:Memory_54",
    "index":0.6512820512820513
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_60",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_10:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6564102564102564
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_64",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_10:Memory_54",
    "index":0.6615384615384615
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_61",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_11:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6666666666666666
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_65",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_11:Memory_54",
    "index":0.6717948717948717
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_62",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_12:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.676923076923077
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_66",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_12:Memory_54",
    "index":0.6820512820512821
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_63",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_13:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6871794871794872
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_67",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_13:Memory_54",
    "index":0.6923076923076923
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_64",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_14:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.6974358974358974
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_68",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_14:Memory_54",
    "index":0.7025641025641025
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_65",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_15:Memory_54/ramsSpWf:RamInitSpWf_50",
    "index":0.7076923076923077
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_69",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/rotation45deg_15:Memory_54",
    "index":0.7128205128205128
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_66",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_0:Memory_38/ramsSpWf:RamInitSpWf_34",
    "index":0.717948717948718
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_70",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_0:Memory_38",
    "index":0.7230769230769231
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_67",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_1:Memory_39/ramsSpWf:RamInitSpWf_35",
    "index":0.7282051282051282
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_71",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_1:Memory_39",
    "index":0.7333333333333333
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_68",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_2:Memory_40/ramsSpWf:RamInitSpWf_36",
    "index":0.7384615384615385
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_72",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_2:Memory_40",
    "index":0.7435897435897436
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_69",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_3:Memory_41/ramsSpWf:RamInitSpWf_37",
    "index":0.7487179487179487
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_73",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_3:Memory_41",
    "index":0.7538461538461538
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_70",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_4:Memory_42/ramsSpWf:RamInitSpWf_38",
    "index":0.7589743589743589
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_74",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_4:Memory_42",
    "index":0.764102564102564
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_71",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_5:Memory_43/ramsSpWf:RamInitSpWf_39",
    "index":0.7692307692307693
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_75",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_5:Memory_43",
    "index":0.7743589743589744
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_72",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_6:Memory_44/ramsSpWf:RamInitSpWf_40",
    "index":0.7794871794871795
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_76",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_6:Memory_44",
    "index":0.7846153846153846
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_73",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_7:Memory_45/ramsSpWf:RamInitSpWf_41",
    "index":0.7897435897435897
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_77",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_7:Memory_45",
    "index":0.7948717948717948
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_74",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_8:Memory_46/ramsSpWf:RamInitSpWf_42",
    "index":0.8
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_78",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_8:Memory_46",
    "index":0.8051282051282052
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_75",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_9:Memory_47/ramsSpWf:RamInitSpWf_43",
    "index":0.8102564102564103
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_79",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_9:Memory_47",
    "index":0.8153846153846154
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_76",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_10:Memory_48/ramsSpWf:RamInitSpWf_44",
    "index":0.8205128205128205
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_80",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_10:Memory_48",
    "index":0.8256410256410256
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_77",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_11:Memory_49/ramsSpWf:RamInitSpWf_45",
    "index":0.8307692307692308
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_81",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_11:Memory_49",
    "index":0.8358974358974359
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_78",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_12:Memory_50/ramsSpWf:RamInitSpWf_46",
    "index":0.841025641025641
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_82",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_12:Memory_50",
    "index":0.8461538461538461
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_79",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_13:Memory_51/ramsSpWf:RamInitSpWf_47",
    "index":0.8512820512820513
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_83",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_13:Memory_51",
    "index":0.8564102564102564
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_80",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_14:Memory_52/ramsSpWf:RamInitSpWf_48",
    "index":0.8615384615384616
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_84",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_14:Memory_52",
    "index":0.8666666666666667
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|RamInitSpWf_81",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_15:Memory_53/ramsSpWf:RamInitSpWf_49",
    "index":0.8717948717948718
  },
  {
    "class":"firrtl.transforms.DedupedResult",
    "original":"~Top|Memory_85",
    "duplicate":"~Top|Top/gameTop:GameTop/graphicEngineVGA:GraphicEngineVGA/spriteBlender:SpriteBlender/spriteMemories_15:Memory_53",
    "index":0.8769230769230769
  },
  {
    "class":"firrtl.EmitCircuitAnnotation",
    "emitter":"firrtl.VerilogEmitter"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_89",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_88",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_87",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_86",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_85",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_84",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_83",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_82",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_49",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_48",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_47",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_46",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_45",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_44",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_43",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_42",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_41",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_40",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_39",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_38",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_37",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_36",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_35",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_34",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_50",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_33",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_32",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamSpWf",
    "name":"RamSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8;\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_31",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_30",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_29",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_28",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_27",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_26",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_25",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_24",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_23",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_22",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_21",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_20",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_19",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_18",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_17",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_16",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_15",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_14",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_13",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_12",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_11",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_10",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_9",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_8",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_7",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_6",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_5",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_4",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_3",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_2",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf_1",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"Top.RamInitSpWf",
    "name":"RamInitSpWf.v",
    "text":"//////////////////////////////////////////////////////////////////////////////\n// Authors: Luca Pezzarossa\n// Copyright: Technical University of Denmark - 2024\n// Comments:\n// Single-Port Block RAM Write-First Mode with initialization form MEM file\n// (recommended template from AMD/Xilinx)\n//////////////////////////////////////////////////////////////////////////////\n\n`timescale 1ns / 1ps\n\nmodule RamInitSpWf ( clk,\n                    we, \n                    en, \n                    addr, \n                    di, \n                    dout);\n\n    parameter\n              ADDR_WIDTH = 8,\n              DATA_WIDTH = 8,\n              LOAD_FILE = \"\";\n\n    input clk;\n    input we;\n    input en;\n    input [ADDR_WIDTH-1:0] addr;\n    input [DATA_WIDTH-1:0] di;\n    output [DATA_WIDTH-1:0] dout;\n\n    reg [DATA_WIDTH-1:0] RAM [(2**ADDR_WIDTH)-1:0];\n    reg [DATA_WIDTH-1:0] dout;\n    \n    initial begin\n        $readmemb(LOAD_FILE, RAM);\n    end\n\n    always @(posedge clk)\n        begin\n        if (en)\n            begin\n                if (we)\n                    begin\n                    RAM[addr] <= di;\n                    dout <= di;\n                    end\n                else\n                    dout <= RAM[addr];\n            end\n        end\nendmodule\n\n//////////////////////////////////////////////////////////////////////////////\n// End of file\n//////////////////////////////////////////////////////////////////////////////"
  },
  {
    "class":"firrtl.transforms.BlackBoxTargetDirAnno",
    "targetDir":"."
  }
]